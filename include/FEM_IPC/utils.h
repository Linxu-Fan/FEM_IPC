#ifndef UTILS_H
#define UTILS_H


#include "omp.h"
#include <iostream>
#include <vector>
#include <math.h>
#include <fstream>
#include <cmath>
#include <set>
#include <iomanip>
#include <algorithm>
#include <iterator>
#include <map>
#include <unordered_map>
#include <string.h>
#include <cassert>
#include <Eigen/Core>
#include <Eigen/Eigenvalues>
#include <unsupported/Eigen/CXX11/Tensor>
#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <sstream>
#include <cstdio>
#include <cassert>
#include <assert.h>
#include <cstring>
#include <cfloat>
#include <complex>

#define PI_Value 3.14159265358979323846 

const double PI = 3.141592653589793238463L;
const double M_2PI = 2 * PI;
const double eps = 1e-12;

typedef std::complex<double> DComplex;


typedef Eigen::Matrix<int, 7, 1> Vector7i;
typedef Eigen::Matrix<double, 9, 1> Vector9d;


struct FEMParamters
{
    double dt = 1.0E-5; // simulation timestep size
    int num_timesteps = 1000000; // the number of simulation timesteps
    Eigen::Vector3d gravity = { 0,0,-9.8 }; // the gravity magnitude and direction
    int outputFrequency = 200; // export the simulation result per interval
    std::string model = "ARAP";
};



// split a line from a text file
std::vector<std::string> split(const std::string& s, const std::string& seperator);

// flaten a 3x3 matrix into a vector
Vector9d flatenMatrix3d(const Eigen::Matrix3d & matrix);

// convert a vector to a cross-product matrix. Eq.4.23 in Kim_Eberle_2022
Eigen::Matrix3d vector2CrossProductMatrix(const Eigen::Vector3d& vec);






// The following code is generated by Huancheng
void ComputeEigenvector0(double a00, double a01, double a02, double a11, double a12, double a22, double eval0, Eigen::Vector3d& evec0);

void ComputeOrthogonalComplement(Eigen::Vector3d const& W, Eigen::Vector3d& U, Eigen::Vector3d& V);

void ComputeEigenvector1(double a00, double a01, double a02, double a11, double a12, double a22, Eigen::Vector3d const& evec0, double eval1, Eigen::Vector3d& evec1);


//---------------------------------------------------------------------------
// useful for testing
inline DComplex polinom_2(DComplex x, double a, double b)
{
	//Horner's scheme for x*x + a*x + b
	return x * (x + a) + b;
}

//---------------------------------------------------------------------------
// useful for testing
inline DComplex polinom_3(DComplex x, double a, double b, double c)
{
	//Horner's scheme for x*x*x + a*x*x + b*x + c;
	return x * (x * (x + a) + b) + c;
}

//---------------------------------------------------------------------------
// useful for testing
inline DComplex polinom_4(DComplex x, double a, double b, double c, double d)
{
	//Horner's scheme for x*x*x*x + a*x*x*x + b*x*x + c*x + d;
	return x * (x * (x * (x + a) + b) + c) + d;
}

//---------------------------------------------------------------------------
// x - array of size 3
// In case 3 real roots: => x[0], x[1], x[2], return 3
//         2 real roots: x[0], x[1],          return 2
//         1 real root : x[0], x[1] � i*x[2], return 1
unsigned int solveP3(double* x, double a, double b, double c);

//---------------------------------------------------------------------------
// Solve quartic equation x^4 + a*x^3 + b*x^2 + c*x + d
// (attention - this function returns dynamically allocated array. It has to be released afterwards)
DComplex* solve_quartic(double a, double b, double c, double d);



#endif